package binaryIO;

import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.geom.AffineTransform;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
public class PolygonScaling {

	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		int N = input.nextInt();
		List<points> listOfpoints = new ArrayList<>();
		List<points> listOfNewPoints = new ArrayList<>();
		
		//Input the Array
		for (int i = 0; i < N ; i++) {
			listOfpoints.add(new points(input.nextInt(),input.nextInt()));
		}
		//Showing the Array
		for (int i = 0; i < N ; i++) {
			System.out.print(listOfpoints.get(i).getX());
			System.out.print(listOfpoints.get(i).getY());
			System.out.println();
		}
		//Taking Other Inputs
		int angle = input.nextInt();
		int scalingFactor = input.nextInt();
		int[] contextPoint = {input.nextInt(),input.nextInt()};
		
		for (int i = 0; i < N ; i++){
			int x = listOfpoints.get(i).getX();
			int y = listOfpoints.get(i).getY();
			float disX = Math.abs(contextPoint[0] - x);
			float disY = Math.abs(contextPoint[1] - y);
			//distance between two points
			float dist = (float) Math.sqrt( disX*disX + disY*disY );
			
			//Rotation : Concatenates this transform with a 
			//transform that rotates coordinates around an anchor point.
			AffineTransform rotation = new AffineTransform();
			rotation.rotate(angle, contextPoint[0], contextPoint[1]);
			rotation.transform({listOfpoints.get(i).getX()][listOfpoints.get(i).getY()},{listOfNewPoints.get(i).getX()][listOfNewPoints.get(i).getY()]};
			
			

			
				
		}
	}
	private static void scale(int points) {
		
	}

	private static void rotate(int angle,int x1,int y1) {
		
		
	}
}

